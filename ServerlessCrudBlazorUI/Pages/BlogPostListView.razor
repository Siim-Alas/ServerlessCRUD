@page "/blogposts"

@using ServerlessCrudClassLibrary
@using ServerlessCrudBlazorUI.Services
@using ServerlessCrudClassLibrary.Utilities
@using Microsoft.Azure.Cosmos.Table

@inject UnauthorizedCrudFunctionAPIClient client

<h3>Blog Posts</h3>

@if (hasInitialized)
{
    <ul class="list-group">
        @foreach (BlogPostEntity post in blogPosts[index])
        {
            <NavLink class="list-group-item  list-group-item-action"
                     href="@($"/detail/{PrettyPrinter.DateStringFromBlogPostPartitionKey(post.PartitionKey)}/{post.RowKey}")">
                <div>
                    <h4>
                        @post.Title
                    </h4>
                    <p class="text-muted">
                        By @post.Author &mdash; @post.Timestamp.ToLocalTime().ToString("d MMMM yyyy")
                    </p>
                </div>
                <div class="">
                    <p class="">
                        @((post.Text.Length < 300) ? post.Text : $"{post.Text.Substring(0, 300)} ...")
                    </p>
                </div>
            </NavLink>
        }
    </ul>

    <ul class="pagination justify-content-center">
        <li class="page-item">
            <button class="page-link" type="button" @onclick="@(async() => await GoToIndex(0))">First</button>
        </li>
        <li class="page-item @((index == 0) ? "disabled" : "")">
            <button class="page-link" type="button" @onclick="Previous">Previous</button>
        </li>

        @for (int i = (index < radiusOfPages) ? 0 : index - radiusOfPages; i <= ((index + radiusOfPages < numOfPages) ? index + radiusOfPages : numOfPages - 1); i++)
        {
            // Workaround, since i gets incremented, but a is declared local to the loop.
            int a = i;
            <li class="page-item @((i == index) ? "active" : "")">
                <button class="page-link" type="button" @onclick="@(async() => await GoToIndex(a))">@(i + 1)</button>
            </li>
        }

        <li class="page-item @((index + 1 < numOfPages) ? "" : "disabled")">
            <button class="page-link" type="button" @onclick="Next">Next</button>
        </li>
        <li class="page-item">
            <button class="page-link" type="button" @onclick="@(async() => await GoToIndex(numOfPages - 1))">Last</button>
        </li>
    </ul>
}
else
{
    <p>
        Fetching blog posts...
    </p>
}

@code {
    private bool hasInitialized = false;
    private readonly static int numberOfEntitiesOnPage = 2;
    private readonly static int radiusOfPages = 3;

    private int index { get; set; } = 0;
    private QueryBlogPostEntitiesRequest request { get; set; }
    private List<List<BlogPostEntity>> blogPosts { get; set; }
    private TableMetadata metadata { get; set; }
    private string userName { get; set; }

    private int numOfPages { get { return (int)Math.Ceiling((decimal)(metadata.NumberOfEntities) / (decimal)numberOfEntitiesOnPage); } }
    private bool allPagesDisplayed { get { return numOfPages <= 2 * radiusOfPages + 1; } }

    private async Task GetNewPosts()
    {
        request = await client.PostQueryBlogPostsRequestAsync(request);
    }

    private async Task GoToIndex(int i)
    {
        // Go "back" (left).
        if (i < index)
        {
            // The page is already loaded into memory.
            if (blogPosts[i].Count > 0)
            {
                index = i;
                return;
            }
            // Else, go back until you find the first page loaded into memory.
            int j = index;
            int k = 0;
            while (blogPosts[--j].Count == 0)
            {
                // Count the amount of pages to be skipped.
                k++;
            }
            // Configure the request.
            request.ContinuationToken = new TableContinuationToken()
            {
                NextPartitionKey = blogPosts[j].Last().PartitionKey,
                NextRowKey = blogPosts[j].Last().RowKey,
                NextTableName = null,
                TargetLocation = StorageLocation.Primary
            };
            request.Skip = 1 + k * numberOfEntitiesOnPage;

            request = await client.PostQueryBlogPostsRequestAsync(request);
            blogPosts[i] = request.BlogPosts;
            index = i;

        }
        // Go "forwards" (right).
        else if (i > index)
        {
            request.Skip = (i - index - 1) * numberOfEntitiesOnPage;
            request = await client.PostQueryBlogPostsRequestAsync(request);
            blogPosts[i] = request.BlogPosts;
            index = i;
        }
    }

    private void Previous()
    {
        if (--index < 0)
        {
            index = 0;
        }
    }

    private async Task Next()
    {
        if (index + 1 < numOfPages)
        {
            await GetNewPosts();
            blogPosts.Add(request.BlogPosts);
            index++;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        metadata = await client.GetTableMetadataAsync();

        request = new QueryBlogPostEntitiesRequest(takeCount: numberOfEntitiesOnPage);

        await GetNewPosts();

        blogPosts = new List<List<BlogPostEntity>>(numOfPages)
        {
            request.BlogPosts
        };

        hasInitialized = true;
    }
}
